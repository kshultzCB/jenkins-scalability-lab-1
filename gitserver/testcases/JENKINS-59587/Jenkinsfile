/*
Devin's incredibly clever way to do this testing follows below. This 
is lifted in its entirety from a ticket.
*/

// Property accesses like `map.A` cause Groovy to try to load `map$A` and `map.A` as classes.
def map = ['A': ['B': ['C': ['D': ['E': ['F': true]]]]]]
def a = map.A
def b = map.A.B
def bA = a.B
def c = map.A.B.C
def cA = a.B.C
def cB = b.C
def d = map.A.B.C.D
def dA = a.B.C.D
def dB = b.C.D
def dC = c.D
def e = map.A.B.C.D.E
def eA = a.B.C.D.E
def eB = b.C.D.E
def eC = c.D.E
def eD = d.E
def f = map.A.B.C.D.E.F
def fA = a.B.C.D.E.F
def fB = b.C.D.E.F
def fC = c.D.E.F
def fD = d.E.F
def fE = e.F

// Clears out the cache before PR 265, could happen if Jenkins was under heavy load
System.gc()

// Load all of the same classes again
map = ['A': ['B': ['C': ['D': ['E': ['F': true]]]]]]
def a = map.A
def b = map.A.B
def bA = a.B
def c = map.A.B.C
def cA = a.B.C
def cB = b.C
def d = map.A.B.C.D
def dA = a.B.C.D
def dB = b.C.D
def dC = c.D
def e = map.A.B.C.D.E
def eA = a.B.C.D.E
def eB = b.C.D.E
def eC = c.D.E
def eD = d.E
def f = map.A.B.C.D.E.F
def fA = a.B.C.D.E.F
def fB = b.C.D.E.F
def fC = c.D.E.F
def fD = d.E.F
def fE = e.F
def abc = map.A.B.C
def abcd = map.A.B.D
def abcde = map.A.B.C.D.E
def abcdef = map.A.B.C.D.E.F

